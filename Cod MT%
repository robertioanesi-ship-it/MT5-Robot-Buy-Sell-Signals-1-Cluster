//+------------------------------------------------------------------+
//|                    Spike Detection Cluster Strategy EA          |
//|                    100% IDENTICAL TradingView Logic             |
//|                    Uses Pipscode Spike Detection Algorithm      |
//+------------------------------------------------------------------+
#include <Trade\Trade.mqh>

#property copyright "100% TradingView Spike Detection Logic"
#property version   "3.00"

// Enumerare pentru tipul de trading pivot
enum ENUM_PIVOT_TRADING_TYPE
{
    PIVOT_BUY_ONLY = 0,    // Doar semnale BUY
    PIVOT_SELL_ONLY = 1,   // Doar semnale SELL
    PIVOT_BOTH = 2         // Ambele semnale
};

//--- Input parameters
input string separator1 = "=== SPIKE DETECTION SETTINGS ===";
input string PivotSymbol = "USDCAD";                        // Pivot pair for spike signals
input ENUM_TIMEFRAMES PivotTimeframe = PERIOD_M15;           // Timeframe (M15 recommended for TV settings)
input ENUM_PIVOT_TRADING_TYPE PivotTradingType = PIVOT_BOTH; // Pivot Trading Type

input string separator1a = "=== EXACT TRADINGVIEW PARAMETERS ===";
input double SpikeThreshold = 0.2;                          // Spike Threshold % (EXACT TV default)
input double VolumeMultiplier = 1.5;                        // Volume Spike Multiplier (EXACT TV default)
input int VolumePeriod = 14;                               // Volume Average Period (EXACT TV)
input int MomentumPeriod = 3;                              // Momentum Period (EXACT TV)
input int BreakoutLookback = 10;                           // Breakout Lookback Period (EXACT TV)

input string separator1b = "=== CLONE TIMING SETTINGS ===";
input int MinTimeBetweenClones = 60;                       // Min minutes between clones (reduced for more signals)
input int MaxClonesPerDirection = 3;                       // Max clones per direction (increased)

input string separator1c = "=== TRADINGVIEW DISPLAY SETTINGS ===";
input bool ShowSignals = true;                             // Show Spike Signals (from TV)
input bool ShowBreakoutLevels = false;                     // Show Breakout Levels (from TV)
input bool AlertEnabled = true;                            // Enable Alerts (from TV)

input string separator2 = "=== BUY SIGNAL PARAMETERS ===";
input string BuySignal_Pair1 = "EURCAD";                    // Buy Signal - Pair 1
input double BuySignal_Volume1 = 0.10;                      // Buy Signal - Volume for Pair 1
input ENUM_POSITION_TYPE BuySignal_OrderType1 = POSITION_TYPE_BUY; // Buy Signal - Order Type for Pair 1
input string BuySignal_Pair2 = "EURUSD";                    // Buy Signal - Pair 2
input double BuySignal_Volume2 = 0.10;                      // Buy Signal - Volume for Pair 2
input ENUM_POSITION_TYPE BuySignal_OrderType2 = POSITION_TYPE_SELL; // Buy Signal - Order Type for Pair 2

input string separator3 = "=== SELL SIGNAL PARAMETERS ===";
input string SellSignal_Pair1 = "EURCAD";                   // Sell Signal - Pair 1
input double SellSignal_Volume1 = 0.10;                     // Sell Signal - Volume for Pair 1
input ENUM_POSITION_TYPE SellSignal_OrderType1 = POSITION_TYPE_BUY; // Sell Signal - Order Type for Pair 1
input string SellSignal_Pair2 = "EURUSD";                   // Sell Signal - Pair 2
input double SellSignal_Volume2 = 0.10;                     // Sell Signal - Volume for Pair 2
input ENUM_POSITION_TYPE SellSignal_OrderType2 = POSITION_TYPE_SELL; // Sell Signal - Order Type for Pair 2

input ulong BuySignal_MagicNumber = 11111;                  // Magic number for Buy Signal cluster
input ulong SellSignal_MagicNumber = 22222;                 // Magic number for Sell Signal cluster

//--- Global variables for TradingView Spike Detection
int rsiHandle = INVALID_HANDLE, atrHandle = INVALID_HANDLE;
datetime lastSignalTime = 0;
double initialEquity = 0;

// Variabile dinamice pentru activarea semnalelor bazate pe selectia pivot
bool EnableBuySignal = true;
bool EnableSellSignal = true;

// TradingView spike detection calculation arrays
double rsiValues[];
double atrValues[];

//=================================================================
//                    BUY SIGNAL MANAGEMENT
//=================================================================
CTrade BuySignalTrade;

// BUY SIGNAL - Main positions
bool BuySignal_MainActive = false;
ulong BuySignal_Main_Ticket1 = 0;     // Ticket for BuySignal_Pair1
ulong BuySignal_Main_Ticket2 = 0;     // Ticket for BuySignal_Pair2

// BUY SIGNAL - Clone positions  
struct BuyClone {
    bool Active;
    ulong Ticket1;
    ulong Ticket2;
    datetime OpenTime;
};
BuyClone BuySignal_Clones[];
int BuySignal_ClonesCount = 0;
datetime BuySignal_LastCloneTime = 0;

//=================================================================
//                    SELL SIGNAL MANAGEMENT  
//=================================================================
CTrade SellSignalTrade;

// SELL SIGNAL - Main positions
bool SellSignal_MainActive = false;
ulong SellSignal_Main_Ticket1 = 0;    // Ticket for SellSignal_Pair1
ulong SellSignal_Main_Ticket2 = 0;    // Ticket for SellSignal_Pair2

// SELL SIGNAL - Clone positions
struct SellClone {
    bool Active;
    ulong Ticket1;
    ulong Ticket2;
    datetime OpenTime;
};
SellClone SellSignal_Clones[];
int SellSignal_ClonesCount = 0;
datetime SellSignal_LastCloneTime = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    // Setează opțiunile de trading bazate pe selecția pivot
    switch(PivotTradingType)
    {
        case PIVOT_BUY_ONLY:
            EnableBuySignal = true;
            EnableSellSignal = false;
            break;
        case PIVOT_SELL_ONLY:
            EnableBuySignal = false;
            EnableSellSignal = true;
            break;
        case PIVOT_BOTH:
            EnableBuySignal = true;
            EnableSellSignal = true;
            break;
        default:
            EnableBuySignal = true;
            EnableSellSignal = true;
            break;
    }

    // Setup trade objects with different magic numbers
    BuySignalTrade.SetExpertMagicNumber(BuySignal_MagicNumber);
    SellSignalTrade.SetExpertMagicNumber(SellSignal_MagicNumber);

    // Initialize indicators for TradingView spike detection (exact parameters)
    rsiHandle = iRSI(PivotSymbol, PivotTimeframe, MomentumPeriod, PRICE_CLOSE);
    atrHandle = iATR(PivotSymbol, PivotTimeframe, 14);

    if(rsiHandle == INVALID_HANDLE || atrHandle == INVALID_HANDLE)
    {
        Print("Failed to create indicators for ", PivotSymbol);
        return INIT_FAILED;
    }

    // Setup arrays for TradingView spike detection
    ArrayResize(rsiValues, 100);
    ArrayResize(atrValues, 100);
    ArraySetAsSeries(rsiValues, true);
    ArraySetAsSeries(atrValues, true);

    // Initialize clone arrays
    ArrayResize(BuySignal_Clones, MaxClonesPerDirection);
    ArrayResize(SellSignal_Clones, MaxClonesPerDirection);
    
    for(int i = 0; i < MaxClonesPerDirection; i++)
    {
        BuySignal_Clones[i].Active = false;
        BuySignal_Clones[i].Ticket1 = 0;
        BuySignal_Clones[i].Ticket2 = 0;
        BuySignal_Clones[i].OpenTime = 0;
        
        SellSignal_Clones[i].Active = false;
        SellSignal_Clones[i].Ticket1 = 0;
        SellSignal_Clones[i].Ticket2 = 0;
        SellSignal_Clones[i].OpenTime = 0;
    }

    initialEquity = AccountInfoDouble(ACCOUNT_EQUITY);
    
    // Display configuration
    string pivotTypeStr = "";
    switch(PivotTradingType)
    {
        case PIVOT_BUY_ONLY: pivotTypeStr = "BUY ONLY"; break;
        case PIVOT_SELL_ONLY: pivotTypeStr = "SELL ONLY"; break;
        case PIVOT_BOTH: pivotTypeStr = "BOTH SIGNALS"; break;
    }
    
    Print("================== 100% TRADINGVIEW SPIKE DETECTION EA v3.00 STARTED ==================");
    Print("PIVOT TRADING MODE: ", pivotTypeStr);
    Print("EXACT TV SETTINGS: Threshold=", SpikeThreshold, "% | Volume Multi=", VolumeMultiplier, " | RSI Period=", MomentumPeriod);
    Print("RELAXED CLONE SETTINGS: Min Time=", MinTimeBetweenClones, "min | Max Clones=", MaxClonesPerDirection);
    Print("BUY SIGNAL: ", EnableBuySignal ? "ENABLED" : "DISABLED");
    if(EnableBuySignal)
    {
        Print("  - Pair 1: ", BuySignal_Pair1, " (", BuySignal_OrderType1 == POSITION_TYPE_BUY ? "BUY" : "SELL", ", ", BuySignal_Volume1, " lots)");
        Print("  - Pair 2: ", BuySignal_Pair2, " (", BuySignal_OrderType2 == POSITION_TYPE_BUY ? "BUY" : "SELL", ", ", BuySignal_Volume2, " lots)");
        Print("  - Magic: ", BuySignal_MagicNumber);
    }
    
    Print("SELL SIGNAL: ", EnableSellSignal ? "ENABLED" : "DISABLED");
    if(EnableSellSignal)
    {
        Print("  - Pair 1: ", SellSignal_Pair1, " (", SellSignal_OrderType1 == POSITION_TYPE_BUY ? "BUY" : "SELL", ", ", SellSignal_Volume1, " lots)");
        Print("  - Pair 2: ", SellSignal_Pair2, " (", SellSignal_OrderType2 == POSITION_TYPE_BUY ? "BUY" : "SELL", ", ", SellSignal_Volume2, " lots)");
        Print("  - Magic: ", SellSignal_MagicNumber);
    }
    
    Print("Pivot Symbol: ", PivotSymbol, " | Initial Equity: ", initialEquity);
    Print("==========================================================================");
    
    return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    if(rsiHandle != INVALID_HANDLE) IndicatorRelease(rsiHandle);
    if(atrHandle != INVALID_HANDLE) IndicatorRelease(atrHandle);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // Check for new spike signals using EXACT TradingView logic
    CheckTradingViewSpikeSignals();
    
    // Monitor existing positions
    MonitorPositions();
}

//+------------------------------------------------------------------+
//| Check for TradingView spike detection signals                   |
//+------------------------------------------------------------------+
void CheckTradingViewSpikeSignals()
{
    // Get current market data for pivot symbol
    MqlRates rates[];
    if(CopyRates(PivotSymbol, PivotTimeframe, 0, 50, rates) < 30)
        return;
        
    ArraySetAsSeries(rates, true);
    
    // Get RSI and ATR values
    if(CopyBuffer(rsiHandle, 0, 0, 50, rsiValues) < 30 ||
       CopyBuffer(atrHandle, 0, 0, 50, atrValues) < 30)
        return;
    
    // Check for new bar
    static datetime lastBarTime = 0;
    if(rates[0].time <= lastBarTime)
        return;
    lastBarTime = rates[0].time;
    
    // Calculate TradingView spike detection for current bar (index 1, completed bar)
    bool bullishSpike = DetectTradingViewBullishSpike(rates, 1);
    bool bearishSpike = DetectTradingViewBearishSpike(rates, 1);
    
    // TradingView Alert logging (exact from TV)
    CheckTradingViewAlerts(bullishSpike, bearishSpike, rates, 1);
    
    // Handle BUY signals
    if(bullishSpike && EnableBuySignal)
    {
        if(!BuySignal_MainActive)
        {
            // Open main BUY cluster
            OpenBuyCluster(true); // true = main cluster
            Print("TV BULLISH SPIKE detected - Opening BUY cluster");
        }
        else if(BuySignal_ClonesCount < MaxClonesPerDirection)
        {
            // Check if enough time passed for clone
            if(TimeCurrent() - BuySignal_LastCloneTime >= MinTimeBetweenClones * 60)
            {
                OpenBuyCluster(false); // false = clone cluster
                BuySignal_LastCloneTime = TimeCurrent();
                Print("TV BULLISH SPIKE detected - Opening BUY CLONE #", BuySignal_ClonesCount);
            }
        }
    }
    
    // Handle SELL signals
    if(bearishSpike && EnableSellSignal)
    {
        if(!SellSignal_MainActive)
        {
            // Open main SELL cluster
            OpenSellCluster(true); // true = main cluster
            Print("TV BEARISH SPIKE detected - Opening SELL cluster");
        }
        else if(SellSignal_ClonesCount < MaxClonesPerDirection)
        {
            // Check if enough time passed for clone
            if(TimeCurrent() - SellSignal_LastCloneTime >= MinTimeBetweenClones * 60)
            {
                OpenSellCluster(false); // false = clone cluster
                SellSignal_LastCloneTime = TimeCurrent();
                Print("TV BEARISH SPIKE detected - Opening SELL CLONE #", SellSignal_ClonesCount);
            }
        }
    }
    
    // Exit logic: opposite signal closes all positions
    if(bullishSpike && SellSignal_MainActive)
    {
        CloseAllSellPositions();
        Print("TV BULLISH SPIKE detected - Closing all SELL positions");
    }
    
    if(bearishSpike && BuySignal_MainActive)
    {
        CloseAllBuyPositions();
        Print("TV BEARISH SPIKE detected - Closing all BUY positions");
    }
}

//+------------------------------------------------------------------+
//| TradingView Bullish Spike Detection (100% IDENTICAL)            |
//+------------------------------------------------------------------+
bool DetectTradingViewBullishSpike(MqlRates& rates[], int index)
{
    if(index >= ArraySize(rates) - VolumePeriod)
        return false;
    
    // ============ PRICE SPIKE DETECTION (100% identical to TV) ============
    // price_change = math.abs(close - open) / open * 100
    double price_change = MathAbs(rates[index].close - rates[index].open) / rates[index].open * 100.0;
    
    // avg_price_change = ta.sma(math.abs(close - open) / open * 100, 10)
    double avg_price_change = 0.0;
    for(int i = 0; i < 10 && (index + i) < ArraySize(rates); i++)
    {
        avg_price_change += MathAbs(rates[index + i].close - rates[index + i].open) / rates[index + i].open * 100.0;
    }
    avg_price_change /= 10.0;
    
    // price_spike = price_change > spike_threshold and price_change > avg_price_change * 1.5
    bool price_spike = (price_change > SpikeThreshold) && (price_change > avg_price_change * 1.5);
    
    // ============ VOLUME SPIKE DETECTION (100% identical to TV) ============
    // avg_volume = ta.sma(volume, volume_period)
    long avg_volume = 0;
    for(int i = 0; i < VolumePeriod && (index + i) < ArraySize(rates); i++)
    {
        avg_volume += rates[index + i].tick_volume;
    }
    avg_volume /= VolumePeriod;
    
    // volume_spike = volume > avg_volume * volume_multiplier
    bool volume_spike = rates[index].tick_volume > avg_volume * VolumeMultiplier;
    
    // ============ MOMENTUM SPIKE DETECTION (100% identical to TV) ============
    // momentum_rsi = ta.rsi(close, momentum_period)
    double momentum_rsi = rsiValues[index];
    // momentum_oversold = momentum_rsi < 30
    bool momentum_oversold = momentum_rsi < 30;
    // momentum_overbought = momentum_rsi > 70
    bool momentum_overbought = momentum_rsi > 70;
    // momentum_spike = momentum_oversold or momentum_overbought
    bool momentum_spike = momentum_oversold || momentum_overbought;
    
    // ============ CANDLE PATTERN DETECTION (100% identical to TV) ============
    // atr_value = ta.atr(14)
    double atr_value = atrValues[index];
    // body_size = math.abs(close - open)
    double body_size = MathAbs(rates[index].close - rates[index].open);
    // candle_range = high - low
    double candle_range = rates[index].high - rates[index].low;
    // big_body = body_size > candle_range * 0.6
    bool big_body = body_size > candle_range * 0.6;
    // strong_candle = big_body and candle_range > atr_value * 1.2
    bool strong_candle = big_body && candle_range > atr_value * 1.2;
    
    // ============ BREAKOUT DETECTION (100% identical to TV) ============
    // resistance = ta.highest(high, lookback)[1]
    double resistance = rates[index + 1].high;
    for(int i = 2; i <= BreakoutLookback && (index + i) < ArraySize(rates); i++)
    {
        if(rates[index + i].high > resistance)
            resistance = rates[index + i].high;
    }
    // breakout_up = close > resistance and volume_spike
    bool breakout_up = rates[index].close > resistance && volume_spike;
    
    // ============ SPIKE COMBINATION LOGIC (100% IDENTICAL TO TV) ============
    // bullish_spike = (close > open) and (price_spike or volume_spike) and (momentum_oversold or strong_candle or breakout_up)
    bool bullish_spike = (rates[index].close > rates[index].open) && 
                        (price_spike || volume_spike) &&  // OR logic as in TV
                        (momentum_oversold || strong_candle || breakout_up);  // OR logic as in TV
    
    return bullish_spike;
}

//+------------------------------------------------------------------+
//| TradingView Bearish Spike Detection (100% IDENTICAL)            |
//+------------------------------------------------------------------+
bool DetectTradingViewBearishSpike(MqlRates& rates[], int index)
{
    if(index >= ArraySize(rates) - VolumePeriod)
        return false;
    
    // ============ PRICE SPIKE DETECTION (100% identical to TV) ============
    double price_change = MathAbs(rates[index].close - rates[index].open) / rates[index].open * 100.0;
    
    double avg_price_change = 0.0;
    for(int i = 0; i < 10 && (index + i) < ArraySize(rates); i++)
    {
        avg_price_change += MathAbs(rates[index + i].close - rates[index + i].open) / rates[index + i].open * 100.0;
    }
    avg_price_change /= 10.0;
    
    bool price_spike = (price_change > SpikeThreshold) && (price_change > avg_price_change * 1.5);
    
    // ============ VOLUME SPIKE DETECTION (100% identical to TV) ============
    long avg_volume = 0;
    for(int i = 0; i < VolumePeriod && (index + i) < ArraySize(rates); i++)
    {
        avg_volume += rates[index + i].tick_volume;
    }
    avg_volume /= VolumePeriod;
    
    bool volume_spike = rates[index].tick_volume > avg_volume * VolumeMultiplier;
    
    // ============ MOMENTUM SPIKE DETECTION (100% identical to TV) ============
    double momentum_rsi = rsiValues[index];
    bool momentum_oversold = momentum_rsi < 30;
    bool momentum_overbought = momentum_rsi > 70;
    bool momentum_spike = momentum_oversold || momentum_overbought;
    
    // ============ CANDLE PATTERN DETECTION (100% identical to TV) ============
    double atr_value = atrValues[index];
    double body_size = MathAbs(rates[index].close - rates[index].open);
    double candle_range = rates[index].high - rates[index].low;
    bool big_body = body_size > candle_range * 0.6;
    bool strong_candle = big_body && candle_range > atr_value * 1.2;
    
    // ============ BREAKOUT DETECTION (100% identical to TV) ============
    double support = rates[index + 1].low;
    for(int i = 2; i <= BreakoutLookback && (index + i) < ArraySize(rates); i++)
    {
        if(rates[index + i].low < support)
            support = rates[index + i].low;
    }
    bool breakout_down = rates[index].close < support && volume_spike;
    
    // ============ SPIKE COMBINATION LOGIC (100% IDENTICAL TO TV) ============
    // bearish_spike = (close < open) and (price_spike or volume_spike) and (momentum_overbought or strong_candle or breakout_down)
    bool bearish_spike = (rates[index].close < rates[index].open) && 
                        (price_spike || volume_spike) &&  // OR logic as in TV
                        (momentum_overbought || strong_candle || breakout_down);  // OR logic as in TV
    
    return bearish_spike;
}

//+------------------------------------------------------------------+
//| Open BUY cluster (main or clone)                               |
//+------------------------------------------------------------------+
void OpenBuyCluster(bool isMain)
{
    if(isMain)
    {
        // Open main BUY cluster
        if(BuySignal_OrderType1 == POSITION_TYPE_BUY)
        {
            if(BuySignalTrade.Buy(BuySignal_Volume1, BuySignal_Pair1))
                BuySignal_Main_Ticket1 = BuySignalTrade.ResultOrder();
        }
        else
        {
            if(BuySignalTrade.Sell(BuySignal_Volume1, BuySignal_Pair1))
                BuySignal_Main_Ticket1 = BuySignalTrade.ResultOrder();
        }
        
        if(BuySignal_OrderType2 == POSITION_TYPE_BUY)
        {
            if(BuySignalTrade.Buy(BuySignal_Volume2, BuySignal_Pair2))
                BuySignal_Main_Ticket2 = BuySignalTrade.ResultOrder();
        }
        else
        {
            if(BuySignalTrade.Sell(BuySignal_Volume2, BuySignal_Pair2))
                BuySignal_Main_Ticket2 = BuySignalTrade.ResultOrder();
        }
            
        if(BuySignal_Main_Ticket1 > 0 && BuySignal_Main_Ticket2 > 0)
        {
            BuySignal_MainActive = true;
            Print("BUY Main Cluster opened: ", BuySignal_Main_Ticket1, " & ", BuySignal_Main_Ticket2);
        }
    }
    else
    {
        // Open clone BUY cluster
        if(BuySignal_ClonesCount < MaxClonesPerDirection)
        {
            int cloneIndex = BuySignal_ClonesCount;
            
            if(BuySignal_OrderType1 == POSITION_TYPE_BUY)
            {
                if(BuySignalTrade.Buy(BuySignal_Volume1, BuySignal_Pair1))
                    BuySignal_Clones[cloneIndex].Ticket1 = BuySignalTrade.ResultOrder();
            }
            else
            {
                if(BuySignalTrade.Sell(BuySignal_Volume1, BuySignal_Pair1))
                    BuySignal_Clones[cloneIndex].Ticket1 = BuySignalTrade.ResultOrder();
            }
            
            if(BuySignal_OrderType2 == POSITION_TYPE_BUY)
            {
                if(BuySignalTrade.Buy(BuySignal_Volume2, BuySignal_Pair2))
                    BuySignal_Clones[cloneIndex].Ticket2 = BuySignalTrade.ResultOrder();
            }
            else
            {
                if(BuySignalTrade.Sell(BuySignal_Volume2, BuySignal_Pair2))
                    BuySignal_Clones[cloneIndex].Ticket2 = BuySignalTrade.ResultOrder();
            }
                
            if(BuySignal_Clones[cloneIndex].Ticket1 > 0 && BuySignal_Clones[cloneIndex].Ticket2 > 0)
            {
                BuySignal_Clones[cloneIndex].Active = true;
                BuySignal_Clones[cloneIndex].OpenTime = TimeCurrent();
                BuySignal_ClonesCount++;
                Print("BUY Clone #", cloneIndex + 1, " opened: ", 
                      BuySignal_Clones[cloneIndex].Ticket1, " & ", BuySignal_Clones[cloneIndex].Ticket2);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Open SELL cluster (main or clone)                              |
//+------------------------------------------------------------------+
void OpenSellCluster(bool isMain)
{
    if(isMain)
    {
        // Open main SELL cluster
        if(SellSignal_OrderType1 == POSITION_TYPE_BUY)
        {
            if(SellSignalTrade.Buy(SellSignal_Volume1, SellSignal_Pair1))
                SellSignal_Main_Ticket1 = SellSignalTrade.ResultOrder();
        }
        else
        {
            if(SellSignalTrade.Sell(SellSignal_Volume1, SellSignal_Pair1))
                SellSignal_Main_Ticket1 = SellSignalTrade.ResultOrder();
        }
        
        if(SellSignal_OrderType2 == POSITION_TYPE_BUY)
        {
            if(SellSignalTrade.Buy(SellSignal_Volume2, SellSignal_Pair2))
                SellSignal_Main_Ticket2 = SellSignalTrade.ResultOrder();
        }
        else
        {
            if(SellSignalTrade.Sell(SellSignal_Volume2, SellSignal_Pair2))
                SellSignal_Main_Ticket2 = SellSignalTrade.ResultOrder();
        }
            
        if(SellSignal_Main_Ticket1 > 0 && SellSignal_Main_Ticket2 > 0)
        {
            SellSignal_MainActive = true;
            Print("SELL Main Cluster opened: ", SellSignal_Main_Ticket1, " & ", SellSignal_Main_Ticket2);
        }
    }
    else
    {
        // Open clone SELL cluster
        if(SellSignal_ClonesCount < MaxClonesPerDirection)
        {
            int cloneIndex = SellSignal_ClonesCount;
            
            if(SellSignal_OrderType1 == POSITION_TYPE_BUY)
            {
                if(SellSignalTrade.Buy(SellSignal_Volume1, SellSignal_Pair1))
                    SellSignal_Clones[cloneIndex].Ticket1 = SellSignalTrade.ResultOrder();
            }
            else
            {
                if(SellSignalTrade.Sell(SellSignal_Volume1, SellSignal_Pair1))
                    SellSignal_Clones[cloneIndex].Ticket1 = SellSignalTrade.ResultOrder();
            }
            
            if(SellSignal_OrderType2 == POSITION_TYPE_BUY)
            {
                if(SellSignalTrade.Buy(SellSignal_Volume2, SellSignal_Pair2))
                    SellSignal_Clones[cloneIndex].Ticket2 = SellSignalTrade.ResultOrder();
            }
            else
            {
                if(SellSignalTrade.Sell(SellSignal_Volume2, SellSignal_Pair2))
                    SellSignal_Clones[cloneIndex].Ticket2 = SellSignalTrade.ResultOrder();
            }
                
            if(SellSignal_Clones[cloneIndex].Ticket1 > 0 && SellSignal_Clones[cloneIndex].Ticket2 > 0)
            {
                SellSignal_Clones[cloneIndex].Active = true;
                SellSignal_Clones[cloneIndex].OpenTime = TimeCurrent();
                SellSignal_ClonesCount++;
                Print("SELL Clone #", cloneIndex + 1, " opened: ", 
                      SellSignal_Clones[cloneIndex].Ticket1, " & ", SellSignal_Clones[cloneIndex].Ticket2);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Close all BUY positions                                         |
//+------------------------------------------------------------------+
void CloseAllBuyPositions()
{
    // Close main positions
    if(BuySignal_MainActive)
    {
        if(BuySignal_Main_Ticket1 > 0)
            BuySignalTrade.PositionClose(BuySignal_Main_Ticket1);
        if(BuySignal_Main_Ticket2 > 0)
            BuySignalTrade.PositionClose(BuySignal_Main_Ticket2);
            
        BuySignal_MainActive = false;
        BuySignal_Main_Ticket1 = 0;
        BuySignal_Main_Ticket2 = 0;
    }
    
    // Close all clones
    for(int i = 0; i < BuySignal_ClonesCount; i++)
    {
        if(BuySignal_Clones[i].Active)
        {
            if(BuySignal_Clones[i].Ticket1 > 0)
                BuySignalTrade.PositionClose(BuySignal_Clones[i].Ticket1);
            if(BuySignal_Clones[i].Ticket2 > 0)
                BuySignalTrade.PositionClose(BuySignal_Clones[i].Ticket2);
                
            BuySignal_Clones[i].Active = false;
            BuySignal_Clones[i].Ticket1 = 0;
            BuySignal_Clones[i].Ticket2 = 0;
        }
    }
    
    BuySignal_ClonesCount = 0;
    BuySignal_LastCloneTime = 0;
}

//+------------------------------------------------------------------+
//| Close all SELL positions                                        |
//+------------------------------------------------------------------+
void CloseAllSellPositions()
{
    // Close main positions
    if(SellSignal_MainActive)
    {
        if(SellSignal_Main_Ticket1 > 0)
            SellSignalTrade.PositionClose(SellSignal_Main_Ticket1);
        if(SellSignal_Main_Ticket2 > 0)
            SellSignalTrade.PositionClose(SellSignal_Main_Ticket2);
            
        SellSignal_MainActive = false;
        SellSignal_Main_Ticket1 = 0;
        SellSignal_Main_Ticket2 = 0;
    }
    
    // Close all clones
    for(int i = 0; i < SellSignal_ClonesCount; i++)
    {
        if(SellSignal_Clones[i].Active)
        {
            if(SellSignal_Clones[i].Ticket1 > 0)
                SellSignalTrade.PositionClose(SellSignal_Clones[i].Ticket1);
            if(SellSignal_Clones[i].Ticket2 > 0)
                SellSignalTrade.PositionClose(SellSignal_Clones[i].Ticket2);
                
            SellSignal_Clones[i].Active = false;
            SellSignal_Clones[i].Ticket1 = 0;
            SellSignal_Clones[i].Ticket2 = 0;
        }
    }
    
    SellSignal_ClonesCount = 0;
    SellSignal_LastCloneTime = 0;
}

//+------------------------------------------------------------------+
//| Monitor existing positions                                       |
//+------------------------------------------------------------------+
void MonitorPositions()
{
    // Check if positions still exist and update status
    // This function ensures consistency between our tracking variables
    // and actual positions in the account
    
    // Check BUY main positions
    if(BuySignal_MainActive)
    {
        if(!PositionSelectByTicket(BuySignal_Main_Ticket1) && !PositionSelectByTicket(BuySignal_Main_Ticket2))
        {
            BuySignal_MainActive = false;
            BuySignal_Main_Ticket1 = 0;
            BuySignal_Main_Ticket2 = 0;
            Print("BUY Main cluster closed externally");
        }
    }
    
    // Check BUY clone positions
    for(int i = 0; i < BuySignal_ClonesCount; i++)
    {
        if(BuySignal_Clones[i].Active)
        {
            if(!PositionSelectByTicket(BuySignal_Clones[i].Ticket1) && 
               !PositionSelectByTicket(BuySignal_Clones[i].Ticket2))
            {
                BuySignal_Clones[i].Active = false;
                BuySignal_Clones[i].Ticket1 = 0;
                BuySignal_Clones[i].Ticket2 = 0;
                Print("BUY Clone #", i + 1, " closed externally");
            }
        }
    }
    
    // Check SELL main positions
    if(SellSignal_MainActive)
    {
        if(!PositionSelectByTicket(SellSignal_Main_Ticket1) && !PositionSelectByTicket(SellSignal_Main_Ticket2))
        {
            SellSignal_MainActive = false;
            SellSignal_Main_Ticket1 = 0;
            SellSignal_Main_Ticket2 = 0;
            Print("SELL Main cluster closed externally");
        }
    }
    
    // Check SELL clone positions
    for(int i = 0; i < SellSignal_ClonesCount; i++)
    {
        if(SellSignal_Clones[i].Active)
        {
            if(!PositionSelectByTicket(SellSignal_Clones[i].Ticket1) && 
               !PositionSelectByTicket(SellSignal_Clones[i].Ticket2))
            {
                SellSignal_Clones[i].Active = false;
                SellSignal_Clones[i].Ticket1 = 0;
                SellSignal_Clones[i].Ticket2 = 0;
                Print("SELL Clone #", i + 1, " closed externally");
            }
        }
    }
}

//+------------------------------------------------------------------+
//| TradingView Background Color Detection (Exact from TV)          |
//+------------------------------------------------------------------+
bool DetectExtremeSpike(MqlRates& rates[], int index)
{
    // bgcolor(price_change > spike_threshold * 2 ? color.new(color.yellow, 90) : na)
    double price_change = MathAbs(rates[index].close - rates[index].open) / rates[index].open * 100.0;
    
    // Get volume spike for extreme condition
    long avg_volume = 0;
    for(int i = 0; i < VolumePeriod && (index + i) < ArraySize(rates); i++)
    {
        avg_volume += rates[index + i].tick_volume;
    }
    avg_volume /= VolumePeriod;
    bool volume_spike = rates[index].tick_volume > avg_volume * VolumeMultiplier;
    
    // Extreme spike condition from TradingView alert: price_change > spike_threshold * 2 and volume_spike
    return (price_change > SpikeThreshold * 2.0) && volume_spike;
}

//+------------------------------------------------------------------+
//| TradingView Alert Conditions (Exact from TV)                    |
//+------------------------------------------------------------------+
void CheckTradingViewAlerts(bool bullish_spike, bool bearish_spike, MqlRates& rates[], int index)
{
    if(!AlertEnabled)
        return;
    
    // alertcondition(bullish_spike and alert_enabled, "Bullish Spike Alert", "BULLISH SPIKE DETECTED!")
    if(bullish_spike)
    {
        Print("TRADINGVIEW ALERT: BULLISH SPIKE DETECTED! Time: ", TimeToString(rates[index].time));
        // Here you could add additional alert logic (email, push notifications, etc.)
    }
    
    // alertcondition(bearish_spike and alert_enabled, "Bearish Spike Alert", "BEARISH SPIKE DETECTED!")
    if(bearish_spike)
    {
        Print("TRADINGVIEW ALERT: BEARISH SPIKE DETECTED! Time: ", TimeToString(rates[index].time));
        // Here you could add additional alert logic
    }
    
    // alertcondition(price_change > spike_threshold * 2 and volume_spike, "EXTREME Spike Alert", "EXTREME SPIKE DETECTED!")
    if(DetectExtremeSpike(rates, index))
    {
        Print("TRADINGVIEW ALERT: EXTREME SPIKE DETECTED! Time: ", TimeToString(rates[index].time));
        // Here you could add additional alert logic for extreme spikes
    }
}

//+------------------------------------------------------------------+
//| TradingView Support/Resistance Levels (Exact from TV)           |
//+------------------------------------------------------------------+
struct SupportResistanceLevels
{
    double resistance;  // ta.highest(high, lookback)[1]
    double support;     // ta.lowest(low, lookback)[1]
    datetime time;
};

SupportResistanceLevels CalculateTradingViewLevels(MqlRates& rates[], int index)
{
    SupportResistanceLevels levels;
    
    // resistance = ta.highest(high, lookback)[1]
    levels.resistance = rates[index + 1].high;
    for(int i = 2; i <= BreakoutLookback && (index + i) < ArraySize(rates); i++)
    {
        if(rates[index + i].high > levels.resistance)
            levels.resistance = rates[index + i].high;
    }
    
    // support = ta.lowest(low, lookback)[1]
    levels.support = rates[index + 1].low;
    for(int i = 2; i <= BreakoutLookback && (index + i) < ArraySize(rates); i++)
    {
        if(rates[index + i].low < levels.support)
            levels.support = rates[index + i].low;
    }
    
    levels.time = rates[index].time;
    return levels;
}

//+------------------------------------------------------------------+
//| Additional TradingView Debug Information                         |
//+------------------------------------------------------------------+
void PrintTradingViewDebugInfo(MqlRates& rates[], int index, bool bullish_spike, bool bearish_spike)
{
    if(!ShowSignals)
        return;
        
    static datetime lastDebugTime = 0;
    if(rates[index].time == lastDebugTime)
        return;
    lastDebugTime = rates[index].time;
    
    // Calculate all TradingView components for debugging
    double price_change = MathAbs(rates[index].close - rates[index].open) / rates[index].open * 100.0;
    
    long avg_volume = 0;
    for(int i = 0; i < VolumePeriod && (index + i) < ArraySize(rates); i++)
    {
        avg_volume += rates[index + i].tick_volume;
    }
    avg_volume /= VolumePeriod;
    bool volume_spike = rates[index].tick_volume > avg_volume * VolumeMultiplier;
    
    double momentum_rsi = rsiValues[index];
    bool momentum_oversold = momentum_rsi < 30;
    bool momentum_overbought = momentum_rsi > 70;
    
    double atr_value = atrValues[index];
    double body_size = MathAbs(rates[index].close - rates[index].open);
    double candle_range = rates[index].high - rates[index].low;
    bool strong_candle = (body_size > candle_range * 0.6) && (candle_range > atr_value * 1.2);
    
    if(bullish_spike || bearish_spike)
    {
        Print("=== TRADINGVIEW SPIKE DEBUG ===");
        Print("Time: ", TimeToString(rates[index].time));
        Print("Price Change: ", DoubleToString(price_change, 3), "%");
        Print("Volume Spike: ", volume_spike ? "YES" : "NO", " (Current: ", rates[index].tick_volume, ", Avg: ", avg_volume, ")");
        Print("RSI: ", DoubleToString(momentum_rsi, 2), " (Oversold: ", momentum_oversold, ", Overbought: ", momentum_overbought, ")");
        Print("Strong Candle: ", strong_candle ? "YES" : "NO");
        Print("Signal: ", bullish_spike ? "BULLISH" : (bearish_spike ? "BEARISH" : "NONE"));
        Print("===============================");
    }
}

//+------------------------------------------------------------------+
//| Get symbol point value                                          |
//+------------------------------------------------------------------+
double GetSymbolPoint(string symbol)
{
    return SymbolInfoDouble(symbol, SYMBOL_POINT);
}

//+------------------------------------------------------------------+
//| Get symbol digits                                               |
//+------------------------------------------------------------------+
int GetSymbolDigits(string symbol)
{
    return (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
}
